#[
    RailDriver. Smart Locomotive Control script for Garry's Mod Train Build Servers.
    Copyright Â© 2022, Cassandra "ZZ Cat" Robinson. All rights reserved.

    This E2 script is free software: you can redistribute it and/or modify
    it under the terms of the GNU Affero General Public License as
    published by the Free Software Foundation, either version 3 of the
    License, or (at your option) any later version.

    This E2 script is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Affero General Public License for more details.

    You should have received a copy of the GNU Affero General Public License
    along with this E2 script.  If not, see <https://www.gnu.org/licenses/>.
]#

@name RailDriver
@model models/beer/wiremod/gate_e2_nano.mdl
@persist Trucks:array Speedo:table
@persist [Direction Throttle Brake EmergencyBrake]:number
@persist [PlayerControls ThrottleMap BrakeMap]:table TrainDriver:entity
@persist PIDF:table
@persist EmBrakeState EmBrakeThisSpeed EmBrakeLastSpeed EmBrakeObserverTickInterval EmBrakePCFaultTimeoutSet
@persist Speed SpeedAbs SpeedMPH
@outputs Debugger:table
@strict

if (first() | duped())
{
    local PIDCoefficientKp = 1020
    local PIDCoefficientKi = 850
    local PIDCoefficientKd = 10

    local PIDItermDecayRate = 0.5
    local PIDItermDecayThreshold = 3.0 * 17.6
    local PIDItermDecayHysteresis = 1

    local PIDItermLimit = 75000
    local PIDOutputLimit = 75000

    local SpeedometerFilterCutoffFrequency = 1
    local SpeedometerDeadband = 0.1

    try
    {
        #include "e2shared/RailDriver/lib/smartEntityManagement"
        #include "e2shared/RailDriver/lib/sensors/speedometer"
        #include "e2shared/RailDriver/lib/controls/playerControls"
        #include "e2shared/RailDriver/lib/pidf"

        # Initialize Smart Entity Management.
        if (semInit())
        {

            if (!semParentToLocomotive())
            {
                error("Failed to parent E2 to locomotive.")
            }

            Trucks = semFindTrucks()
            if (!semValidateTrucks(Trucks))
            {
                error("Locomotive trucks are not valid physics objects.")
            }
        }

        else
        {
            error("RailDriver: Failed to initialize Smart Entity Management.")
        }

        # Initialize Speedometer.
        Speedo = speedometerInit(Trucks[1, entity], Trucks[2, entity])
        if (Speedo:count() == 8)
        {
            speedometerSetFilterCutoffFrequency(Speedo, SpeedometerFilterCutoffFrequency)
            speedometerSetDeadband(Speedo, SpeedometerDeadband * 17.6)
            speedometerStart(Speedo)
        }

        else
        {
            error("RailDriver: Failed to initialize Speedometer.")
        }

        # Setup throttle and brake maps.
        ThrottleMap["Throttle Input Type", string] = "Velocity"
        ThrottleMap["Velocity Setpoint", array] = array(0, 5, 15, 20, 30, 40, 60)
        ThrottleMap["Acceleration Setpoint", array] = array(0, 0.5, 1, 1.5, 2, 2.5, 3)
        ThrottleMap["Torque Setpoint", array] = array(0, 1000, 2000, 3000, 4000, 5000, 6000)
        BrakeMap["Brake Input Type", string] = "Velocity"
        BrakeMap["Velocity Setpoint", array] = array(0, 0, 0, 0, 0, 0, 0)
        BrakeMap["Deceleration Setpoint", array] = array(0, -0.5, -1, -1.5, -2, -2.5, -3)
        BrakeMap["Torque Setpoint", array] = array(0, -1000, -2000, -3000, -4000, -5000, -6000)

        # Setup default key bindings.
        local KeyboardControls = table()
        KeyboardControls["Increase Reverser", string] = "W"
        KeyboardControls["Decrease Reverser", string] = "S"
        KeyboardControls["Increase Throttle", string] = "D"
        KeyboardControls["Decrease Throttle", string] = "A"
        KeyboardControls["Increase Brake", string] = "left ctrl + D"
        KeyboardControls["Decrease Brake", string] = "left ctrl + A"
        KeyboardControls["Emergency Brake", string] = "space"
        KeyboardControls["Horn", string] = "H"
        KeyboardControls["Bell", string] = "left alt"
        KeyboardControls["Headlights", string] = "F"
        KeyboardControls["Ditch Lights", string] = "left shift + F"

        # Set the driver to the player who spawned the E2.
        TrainDriver = owner()

        # Initialize Player Controls.
        PlayerControls = playerControlsInit(KeyboardControls, ThrottleMap, BrakeMap, TrainDriver)
        if (PlayerControls:count() == 0)
        {
            error("Failed to initialize Player Controls.")
        }

        Direction = 0
        Throttle = 1
        Brake = 1
        EmergencyBrake = 0

        # Initialize the PIDF controller.
        PIDF = pidCreateInstance()
        if (PIDF:count() == 55)
        {
            # Set the initial PIDF Controller's parameters.
            pidSetPIDcoefficients(PIDF, PIDCoefficientKp, PIDCoefficientKi, PIDCoefficientKd)
            pidSetFFcoefficients(PIDF, 0, 0, 0, 0, 0)
            pidSetItermDecay(PIDF, PIDItermDecayRate, PIDItermDecayThreshold, PIDItermDecayHysteresis)
            pidSetItermLimits(PIDF, -PIDItermLimit, PIDItermLimit)
            pidSetOutputLimits(PIDF, -PIDOutputLimit, PIDOutputLimit)
            pidSetProportionalMode(PIDF, "Proportional on Measurement")
            pidSetMode(PIDF, "Automatic")
            runOnTick(1)
        }

        else 
        {
            error("Failed to initialize PIDF controller.")
        }

        timer("Debug", 100)

        #[
            Lock the E2, so that it can't be deleted or edited by anyone
            except you.

            This is not a security measure, as the E2 can still be
            deleted or edited by you. It is only a convenience measure,
            to prevent other users from accidentally or maliciously
            deleting or editing the E2, which would cause RailDriver to
            stop working.

            You can still update the E2 by using the "Update" button in
            the Remote Upload menu of the Expression 2 Tool Gun.
        ]#
        semLockE2()
        assert(semE2IsLocked(), "Failed to lock E2.")
    }

    catch (Exception)
    {
        printColor(vec(255, 0, 0), "[RailDriver | Init | Error]", vec(255, 255, 255), ": " + Exception)
    }
}

if (clk(speedometerGetClockId(Speedo)))
{
    try
    {
        speedometerClearAndRestartTimer(Speedo)

        # Calculate the speed of the locomotive.
        local SpeedRaw = 0
        SpeedRaw = speedometerGetSpeed(Speedo)

        # Apply a deadband & low-pass filter to the speed.
        Speed = speedometerDeadband(Speedo, speedometerFilter(Speedo, SpeedRaw))

        SpeedAbs = abs(Speed)

        # Update the PIDF controller's process variable.
        # This is the measured speed of the locomotive.
        pidSetProcessVariable(PIDF, SpeedAbs)

        # Convert speed from Garry's Mod units to miles per hour.
        SpeedMPH = round(toUnit("mph", SpeedAbs) * 4 / 3)
    }

    catch (Exception)
    {
        printColor(vec(255, 0, 0), "[RailDriver | Speedo | Error]", vec(255, 255, 255), ": " + Exception)
    }
}

if (tickClk())
{
    try
    {
        # Calculate the PIDF controller's output.
        pidCalculate(PIDF) # <--- This is where the magick happens. =^/,..,^=

        # Get the PIDF controller's output.
        # This is the throttle and brake values that will be applied to the locomotive.
        local PIDFOutput = pidGetOutput(PIDF)

        #[ Bypass all of this for now. ]#
        #[
            # Set the throttle and brake values based on the PIDF controller's output and the current reverser position.
            if (Reverser == 1)
            {
                Throttle = PIDFOutput
                Brake = 0
            }

            elseif (Reverser == -1)
            {
                Throttle = 0
                Brake = PIDFOutput
            }

            else
            {
                Throttle = 0
                Brake = 0
            }

            # Apply the throttle, brake, and reverser values to the locomotive's traction motors.
            semControlTrucks(Trucks, Throttle, Brake, Reverser)
        ]#

        # Apply the PIDF Controller's output directly to the locomotive's traction motors.
        if (!semDirectControlTrucks(Trucks, PIDFOutput, Direction))
        {
            #[ 
                Notes from ZZ Cat:
                When 'semDirectControlTrucks()' returns false, the control loop is disabled.
                The E2 is also unlocked, so you can edit or remove it.
                This is to prevent the E2 from being locked forever.

                Through testing, I found a few things:
                - If the trucks are removed from the locomotive, 'semDirectControlTrucks()' will return false.
                  & the speedometer will show an "Invalid entity!" error.
                - If the entire locomotive is removed from the world, 'semDirectControlTrucks()' will return false.
                  & the error below will be printed.
            ]#

            # If the E2 is locked, unlock it.
            # This is to prevent the E2 from being locked forever.
            runOnTick(0)
            if (semE2IsLocked())
            {
                semUnlockE2()
            }

            # Print an error message.
            error("Failed to apply PIDF controller's output to locomotive's traction motors.")
        }
    }

    catch (Exception)
    {
        printColor(vec(255, 0, 0), "[RailDriver | PID | Error]", vec(255, 255, 255), ": " + Exception)
    }
}

if (keyClk())
{
    try
    {
        if (playerControlsUpdate(PlayerControls))
        {
            if (!playerControlsValid(PlayerControls, Speed))
            {
                error(playerControlsGetFaultMessage(PlayerControls))
            }

            if (playerControlsDirectionIsUpdated(PlayerControls))
            {
                Direction = playerControlsGetDirection(PlayerControls)

                # Clear the Direction is Updated flag.
                playerControlsClearDirectionIsUpdated(PlayerControls)
            }

            if (playerControlsThrottleIsUpdated(PlayerControls))
            {
                # Get the current throttle value.
                Throttle = playerControlsGetThrottle(PlayerControls)

                # Get the current velocity setpoint & convert it from miles per hour to Garry's Mod units.
                local VelocitySetpoint = playerControlsGetThrottleMap(PlayerControls, "Velocity Setpoint", Throttle)
                local VelocitySetpointGM = VelocitySetpoint * 17.6

                # Set the PIDF controller's setpoint.
                pidSetFeedforward(PIDF, "Throttle", VelocitySetpointGM)
                pidSetSetPoint(PIDF, VelocitySetpointGM)

                # Clear the Throttle is Updated flag.
                playerControlsClearThrottleIsUpdated(PlayerControls)
            }

            if (playerControlsBrakeIsUpdated(PlayerControls))
            {
                Brake = playerControlsGetBrake(PlayerControls)

                # Brake currently is not used.
                # So, I'm gonna let it silently do nothing. =^/.~=

                # Clear the Brake is Updated flag.
                playerControlsClearBrakeIsUpdated(PlayerControls)
            }

            if (playerControlsEmergencyBrakeIsUpdated(PlayerControls))
            {
                EmergencyBrake = playerControlsGetEmergencyBrake(PlayerControls)

                # If the Emergency Brake is pressed, set the controller's setpoint to 0.
                if (EmergencyBrake)
                {
                    # Initialize the Emergency Brake Observer.
                    # The Emergency Brake's Observer Interval is 2 Hz.
                    EmBrakeState = 1
                    EmBrakeObserverTickInterval = 1000 / 2
                    timer("Emergency Brake", tickInterval())
                }

                # Clear the Emergency Brake is Updated flag.
                playerControlsClearEmergencyBrakeIsUpdated(PlayerControls)
            }
        }
    }

    catch (Exception)
    {
        local ErrorColor = vec(255, 0, 0)
        local ErrorText = "[RailDriver | PlyCtrls | Error]"

        if (Exception:find("Fault Cleared."))
        {
            ErrorColor = vec(0, 255, 0)
            ErrorText = "[RailDriver | PlyCtrls | Fault Cleared]"

            if (EmBrakePCFaultTimeoutSet)
            {
                # Clear the Emergency Brake Observer.
                stoptimer("Emergency Brake")
                EmBrakeState = 0

                # Clear the Emergency Brake is Active flag.
                playerControlsClearEmergencyBrakeIsActive(PlayerControls)
            }
        }

        else
        {
            if (!playerControlsEmergencyBrakeIsActive(PlayerControls))
            {
                if (!EmBrakePCFaultTimeoutSet)
                {
                    # Initialize the Emergency Brake Observer.
                    # The Emergency Brake's Observer Interval is 2 Hz.
                    # The initial timeout is 5 seconds, to give the player time to reset the fault.
                    # After the timeout, the Emergency Brake will be automatically applied.
                    EmBrakeState = 1
                    EmBrakeObserverTickInterval = 1000 / 2
                    timer("Emergency Brake", 5000)
                    EmBrakePCFaultTimeoutSet = 1

                    # Set the Emergency Brake to active.
                    playerControlsSetEmergencyBrakeActive(PlayerControls)
                }
            }
        }

        printColor(ErrorColor, ErrorText, vec(255, 255, 255), ": " + Exception)
    }
}

if (clk("Emergency Brake"))
{
    stoptimer("Emergency Brake")

    try
    {
        # Emergency Brake State Machine.
        # This state machine is an observer that will monitor the locomotive's speed
        # while the Emergency Brake is active.
        # If the locomotive's speed is not decreasing, tougher measures will be taken.
        # When the locomotive is stopped, the Emergency Brake will be released.
        # There are 5 states:
        # 1. The Emergency Brake is activated.
        # 2. The locomotive's speed is decreasing... or is it?
        # 3. The locomotive's speed is not decreasing. Apply the brakes to force the locomotive to stop.
        # 4. The locomotive should be stopped by now. Release the Emergency Brake.
        # 5. The locomotive still isn't stopped? Okay, freeze the entire train & shut RailDriver down.
        #    This is the last resort. Somehow, the locomotive is still moving.
        #    This is a safety measure to prevent the locomotive from derailing &/or causing a collision.
        if (EmBrakeState == 1)
        {
            #[ STOP THE TRAIN!!! ]#

            EmBrakePCFaultTimeoutSet = 0

            # Get the current speed of the locomotive.
            EmBrakeThisSpeed = SpeedAbs
            EmBrakeLastSpeed = SpeedAbs

            # Reset the Throttle & Brake values.
            playerControlsResetThrottle(PlayerControls)

            # Set the PIDF controller's setpoint & feedforward to 0.
            pidSetFeedforward(PIDF, "Throttle", 0)
            pidSetSetPoint(PIDF, 0)

            # Set the Emergency Brake state to 2.
            EmBrakeState = 2

            # Restart the Emergency Brake timer.
            timer("Emergency Brake", EmBrakeObserverTickInterval)
        }

        # Emergency Brake state 2.
        # This state is used to monitor the locomotive's speed to ensure that the locomotive is stopping.
        # If the locomotive's speed is not decreasing, the Emergency Brake state is set to 3.
        # If the locomotive is stopped, the Emergency Brake state is set to 4.
        elseif (EmBrakeState == 2)
        {
            #[ I HOPE IT STOPS! ]#

            # Get the current speed of the locomotive.
            EmBrakeThisSpeed = SpeedAbs

            # If the locomotive's speed is not decreasing, set the Emergency Brake state to 3.
            if (EmBrakeThisSpeed >= EmBrakeLastSpeed)
            {
                EmBrakeState = 3
            }

            # If the locomotive is stopped, set the Emergency Brake state to 4.
            elseif (EmBrakeThisSpeed == 0)
            {
                EmBrakeState = 4
            }

            # Set the last speed to the current speed.
            EmBrakeLastSpeed = EmBrakeThisSpeed

            # Restart the Emergency Brake timer.
            timer("Emergency Brake", EmBrakeObserverTickInterval)
        }

        # Emergency Brake state 3.
        # This state disables the PIDF controller, sets the locomotive's traction motors to 0, &
        # uses the locomotive's brakes to stop the locomotive.
        # If the locomotive is stopped, the Emergency Brake state is set to 4.
        # If the locomotive's speed still is not decreasing, tougher measures are taken.
        elseif (EmBrakeState == 3)
        {
            #[ I WASN'T ASKING!!! ]#

            # Get the current speed of the locomotive.
            EmBrakeThisSpeed = SpeedAbs

            # If the locomotive is stopped, set the Emergency Brake state to 4.
            if (EmBrakeThisSpeed == 0)
            {
                EmBrakeState = 4
            }

            # If the locomotive's speed still is not decreasing, set the Emergency Brake state to 5.
            elseif (EmBrakeThisSpeed >= EmBrakeLastSpeed)
            {
                EmBrakeState = 5
            }

            # Set the last speed to the current speed.
            EmBrakeLastSpeed = EmBrakeThisSpeed

            # Disable the PIDF controller.
            pidSetMode(PIDF, "Manual")
            pidSetOutput(PIDF, 0)
            runOnTick(0)

            # Set the locomotive's traction motors to 0.
            semDirectControlTrucks(Trucks, 0, Direction)

            # Set the locomotive's brakes to 100%.
            semDirectControlBrakes(Trucks, 2)

            # Restart the Emergency Brake timer.
            timer("Emergency Brake", EmBrakeObserverTickInterval)
        }

        # Emergency Brake state 4.
        # This state releases the locomotive's brakes & re-enables the PIDF controller.
        # But first, it needs to ensure that the locomotive is stopped.
        # Then, it verifies that the locomotive is stopped.
        # If the locomotive is stopped, the Emergency Brake state is set to 0.
        # In this state, do the following:
        # - The Emergency Brake is released.
        # - The locomotive's traction motors are set to 0.
        # - The locomotive's brakes are set to 0.
        # - The PIDF controller is re-enabled.
        # Otherwise, if the locomotive is not stopped, the Emergency Brake state is set to 5.
        # Here, I am using the EmBrakeState to determine what the next action should be.
        elseif (EmBrakeState == 4)
        {
            #[ YOU SHOULD HAVE LISTENED TO ME!!! ]#

            # Get the current speed of the locomotive.
            EmBrakeThisSpeed = SpeedAbs

            # If the locomotive is stopped, set the Emergency Brake state to 0.
            if (EmBrakeThisSpeed == 0)
            {
                EmBrakeState = 0
            }

            # If the locomotive is not stopped, set the Emergency Brake state to 5.
            else
            {
                EmBrakeState = 5
            }

            # Set the last speed to the current speed.
            EmBrakeLastSpeed = EmBrakeThisSpeed

            # If the locomotive is stopped, release the Emergency Brake.
            if (EmBrakeState == 0)
            {
                # Release the Emergency Brake.
                playerControlsClearEmergencyBrakeIsActive(PlayerControls)

                # Set the locomotive's traction motors to 0.
                semDirectControlTrucks(Trucks, 0, Direction)

                # Set the locomotive's brakes to 0.
                semDirectControlBrakes(Trucks, 0)

                # Re-enable the PIDF controller.
                pidSetMode(PIDF, "Automatic")
                runOnTick(1)
            }

            # Restart the Emergency Brake timer.
            timer("Emergency Brake", EmBrakeObserverTickInterval)
        }

        # Emergency Brake state 5.
        # This state freezes the entire train, to prevent derailments &/or collisions.
        # This is the last resort to stop the locomotive & it should never be reached.
        # Otherwise, a non-recoverable fault is tripped.
        # This means that RailDriver is completely disabled & it will need to be manually reset.
        # Also, your train will need to be manually unfrozen too.
        elseif (EmBrakeState == 5)
        {
            #[ YA CAN'T RUNAWAY ON ME, IF YOU'RE FROZEN!!! ]#

            # Freeze the entire train.
            semFreezeTrain()
            semDirectControlBrakes(Trucks, 0)

            # Disable RailDriver.
            stopAllTimers()
            runOnKeys(TrainDriver, 0)
            runOnTick(0)

            # Set the Emergency Brake state to 0.
            EmBrakeState = 0

            # Unlock the RailDriver, so that it can be manually reset.
            if (semE2IsLocked())
            {
                semUnlockE2()
            }

            # Display an error message.
            error("The train has been frozen due to a non-recoverable fault.")
        }

        # Emergency Brake state 6.
        # This state is for tuning the Emergency Brake.
        # Only use this state if you know what you are doing.
        # When the locomotive is moving, do the following:
        # - Reset the Throttle.
        # - Set the Setpoint & Feedforward to 0.
        # - Disable the PIDF controller.
        # - Set the locomotive's traction motors to 0.
        # - Set the locomotive's brakes to 100%.
        # When the locomotive is stopped, do the following:
        # - Release the Emergency Brake.
        # - Set the Emergency Brake state to 0.
        # - Re-enable the PIDF controller.
        # - Set the locomotive's traction motors to 0.
        # - Set the locomotive's brakes to 0.
        elseif (EmBrakeState == 6)
        {
            # Get the current speed of the locomotive.
            EmBrakeThisSpeed = SpeedAbs

            # If the locomotive is moving, do the following:
            if (EmBrakeThisSpeed > 0)
            {
                # Reset the Throttle.
                playerControlsResetThrottle(PlayerControls)

                # Set the Setpoint & Feedforward to 0.
                pidSetFeedforward(PIDF, "Throttle", 0)
                pidSetSetPoint(PIDF, 0)

                # Disable the PIDF controller.
                pidSetMode(PIDF, "Manual")
                pidSetOutput(PIDF, 0)
                runOnTick(0)

                # Set the locomotive's traction motors to 0.
                semDirectControlTrucks(Trucks, 0, Direction)

                # Set the locomotive's brakes to 100%.
                semDirectControlBrakes(Trucks, 2)
            }

            # If the locomotive is stopped, do the following:
            else
            {
                # Release the Emergency Brake.
                playerControlsClearEmergencyBrakeIsActive(PlayerControls)

                # Set the Emergency Brake state to 0.
                EmBrakeState = 0

                # Re-enable the PIDF controller.
                pidSetMode(PIDF, "Automatic")
                runOnTick(1)

                # Set the locomotive's traction motors to 0.
                semDirectControlTrucks(Trucks, 0, Direction)

                # Set the locomotive's brakes to 0.
                semDirectControlBrakes(Trucks, 0)
            }

            # Set the last speed to the current speed.
            EmBrakeLastSpeed = EmBrakeThisSpeed

            # Restart the Emergency Brake timer.
            timer("Emergency Brake", EmBrakeObserverTickInterval)
        }
    }

    catch(Exception)
    {
        printColor(vec(255, 0, 0), "[RailDriver | EmBrake | Fatal Error]", vec(255, 255, 255), ": " + Exception)
    }
}

if (clk("Debug"))
{
    stoptimer("Debug")
    timer("Debug", 100)

    # Locomotive's speed.
    Debugger["Speed (Source)", number] = Speed
    Debugger["Speed (mph)", number] = SpeedMPH

    # Player controls.
    #Debugger["Throttle", number] = playerControlsGetThrottle(PlayerControls)
    #Debugger["Brake", number] = playerControlsGetBrake(PlayerControls)
    #Debugger["Reverser", number] = playerControlsGetDirection(PlayerControls)

    # PIDF controller.
    Debugger["PIDF Setpoint", number] = pidGetSetPoint(PIDF) / 17.6

    #Debugger["PIDF Feedforward", number] = pidGetFFsum(PIDF)
    #Debugger["PIDF Process Variable", number] = pidGetProcessVariable(PIDF) / 17.6

    Debugger["PIDF P-Term", number] = pidGetPterm(PIDF)
    Debugger["PIDF I-Term", number] = pidGetIterm(PIDF)
    Debugger["PIDF D-Term", number] = pidGetDterm(PIDF)

    Debugger["PIDF Output", number] = pidGetOutput(PIDF)
}
