#[
    RailDriver. Smart Locomotive Control script for Garry's Mod Train Build Servers.
    Copyright Â© 2022, Cassandra "ZZ Cat" Robinson. All rights reserved.

    This E2 script is free software: you can redistribute it and/or modify
    it under the terms of the GNU Affero General Public License as
    published by the Free Software Foundation, either version 3 of the
    License, or (at your option) any later version.

    This E2 script is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Affero General Public License for more details.

    You should have received a copy of the GNU Affero General Public License
    along with this E2 script.  If not, see <https://www.gnu.org/licenses/>.
]#

@name RailDriver
@model models/beer/wiremod/gate_e2_nano.mdl
@persist Trucks:array Speedo:table
@persist [PlayerControls ThrottleMap BrakeMap]:table TrainDriver:entity
@persist PIDF:table
@persist Speed SpeedMPH
@outputs Debugger:table
@strict

if (first() | duped())
{
    local PIDCoefficientKp = 1020
    local PIDCoefficientKi = 850
    local PIDCoefficientKd = 10

    local PIDItermDecayRate = 0.5
    local PIDItermDecayThreshold = 3.0 * 17.6
    local PIDItermDecayHysteresis = 1

    local PIDItermLimit = 75000
    local PIDOutputLimit = 75000

    local SpeedometerFilterCutoffFrequency = 1
    local SpeedometerDeadband = 0.1

    try
    {
        #include "e2shared/RailDriver/lib/smartEntityManagement"
        #include "e2shared/RailDriver/lib/sensors/speedometer"
        #include "e2shared/RailDriver/lib/controls/playerControls"
        #include "e2shared/RailDriver/lib/pidf"

        # Initialize Smart Entity Management.
        if (semInit())
        {
            #[
                Lock the E2, so that it can't be deleted or edited by anyone
                except you.

                This is not a security measure, as the E2 can still be
                deleted or edited by you. It is only a convenience measure,
                to prevent other users from accidentally or maliciously
                deleting or editing the E2, which would cause RailDriver to
                stop working.

                You can still update the E2 by using the "Update" button in
                the Remote Upload menu of the Expression 2 Tool Gun.
            ]#
            semLockE2()
            assert(semE2IsLocked(), "Failed to lock E2.")

            if (!semParentToLocomotive())
            {
                error("Failed to parent E2 to locomotive.")
            }

            Trucks = semFindTrucks()
            if (!semValidateTrucks(Trucks))
            {
                error("Locomotive trucks are not valid physics objects.")
            }
        }

        else
        {
            error("RailDriver: Failed to initialize Smart Entity Management.")
        }

        # Initialize Speedometer.
        Speedo = speedometerInit(Trucks[1, entity], Trucks[2, entity])
        if (Speedo:count() == 19)
        {
            speedometerSetFilterCutoffFrequency(Speedo, SpeedometerFilterCutoffFrequency)
            speedometerSetDeadband(Speedo, SpeedometerDeadband * 17.6)
            speedometerStart(Speedo)
        }

        else
        {
            error("RailDriver: Failed to initialize Speedometer.")
        }

        # Setup throttle and brake maps.
        ThrottleMap["Throttle Input Type", string] = "Velocity"
        ThrottleMap["Velocity Setpoint", array] = array(0, 5, 15, 20, 30, 40, 60)
        ThrottleMap["Acceleration Setpoint", array] = array(0, 0.5, 1, 1.5, 2, 2.5, 3)
        ThrottleMap["Torque Setpoint", array] = array(0, 1000, 2000, 3000, 4000, 5000, 6000)
        BrakeMap["Brake Input Type", string] = "Velocity"
        BrakeMap["Velocity Setpoint", array] = array(0, 0, 0, 0, 0, 0, 0)
        BrakeMap["Deceleration Setpoint", array] = array(0, -0.5, -1, -1.5, -2, -2.5, -3)
        BrakeMap["Torque Setpoint", array] = array(0, -1000, -2000, -3000, -4000, -5000, -6000)

        # Setup default key bindings.
        local KeyboardControls = table()
        KeyboardControls["Increase Reverser", string] = "W"
        KeyboardControls["Decrease Reverser", string] = "S"
        KeyboardControls["Increase Throttle", string] = "D"
        KeyboardControls["Decrease Throttle", string] = "A"
        KeyboardControls["Increase Train Brake", string] = "left shift + D"
        KeyboardControls["Decrease Train Brake", string] = "left shift + A"
        KeyboardControls["Increase Engine Brake", string] = "left ctrl + D"
        KeyboardControls["Decrease Engine Brake", string] = "left ctrl + A"
        KeyboardControls["Emergency Brake", string] = "space"
        KeyboardControls["Horn", string] = "H"
        KeyboardControls["Bell", string] = "left alt"
        KeyboardControls["Headlights", string] = "F"
        KeyboardControls["Ditch Lights", string] = "left shift + F"

        # Set the driver to the player who spawned the E2.
        TrainDriver = owner()

        # Initialize Player Controls.
        PlayerControls = playerControlsInit(KeyboardControls, ThrottleMap, BrakeMap, TrainDriver)
        if (PlayerControls:count() == 0)
        {
            error("Failed to initialize Player Controls.")
        }

        # Initialize the PIDF controller.
        PIDF = pidCreateInstance()
        if (PIDF:count() == 55)
        {
            # Set the initial PIDF Controller's parameters.
            pidSetPIDcoefficients(PIDF, PIDCoefficientKp, PIDCoefficientKi, PIDCoefficientKd)
            pidSetFFcoefficients(PIDF, 0, 0, 0, 0, 0)
            pidSetItermDecay(PIDF, PIDItermDecayRate, PIDItermDecayThreshold, PIDItermDecayHysteresis)
            pidSetItermLimits(PIDF, -PIDItermLimit, PIDItermLimit)
            pidSetOutputLimits(PIDF, -PIDOutputLimit, PIDOutputLimit)
            pidSetProportionalMode(PIDF, "Proportional on Measurement")
            pidSetMode(PIDF, "Automatic")
            runOnTick(1)
        }

        else 
        {
            error("Failed to initialize PIDF controller.")
        }

        timer("Debug", 100)
    }

    catch (Exception)
    {
        # If an exception is thrown, unlock the E2.
        # This is to prevent the E2 from being locked forever.
        if (semE2IsLocked())
        {
            semUnlockE2()
        }

        #[
            Notes from ZZ Cat:
            I tried to unparent the E2 & re-weld it to the locomotive, but it didn't work.
            I'm not sure why, but I'm not going to spend any more time on it.
            If you know how to fix this, please let me know by opening either an issue or a pull request on GitHub.
        ]#

        printColor(vec(255, 0, 0), "[RailDriver | Init | Error]", vec(255, 255, 255), ": " + Exception)
    }
}

if (clk(speedometerGetClockId(Speedo)))
{
    try
    {
        speedometerClearAndRestartTimer(Speedo)

        local SpeedRaw = 0

        # Calculate the speed of the locomotive.
        SpeedRaw = speedometerGetSpeed(Speedo, playerControlsGetDirection(PlayerControls))
        Speed = speedometerFilter(Speedo, SpeedRaw)

        # Apply a deadband to the speed.
        Speed = speedometerDeadband(Speedo, Speed)

        # Update the PIDF controller's process variable.
        # This is the measured speed of the locomotive.
        pidSetProcessVariable(PIDF, Speed)

        # Convert speed from Garry's Mod units to miles per hour.
        SpeedMPH = round(toUnit("mph", Speed) * 4 / 3)
    }

    catch (Exception)
    {
        printColor(vec(255, 0, 0), "[RailDriver | Speedo | Error]", vec(255, 255, 255), ": " + Exception)
    }
}

if (tickClk())
{
    try
    {
        #[
            TODO:
            - Move the setpoint, throttle, and brake values up to the player controls.
            - Move the throttle & brake feedforward values up to the player controls.
        ]#
        # Get the current throttle and brake values.
        local Throttle = playerControlsGetThrottle(PlayerControls)
        local Brake = playerControlsGetBrake(PlayerControls)
        local Reverser = playerControlsGetDirection(PlayerControls)

        # Get the current velocity setpoint.
        local VelocitySetpoint = playerControlsGetThrottleMap(PlayerControls, "Velocity Setpoint", Throttle)

        # Convert the velocity setpoint from miles per hour to Garry's Mod units.
        local VelocitySetpointGM = VelocitySetpoint * 17.6

        # Set the throttle and brake feedforward values.
        pidSetFeedforward(PIDF, "Throttle", VelocitySetpointGM)
        #pidSetFeedforward(PIDF, "Brake", Brake)

        # Set the PIDF controller's setpoint.
        # This is the desired speed of the locomotive.
        pidSetSetPoint(PIDF, VelocitySetpointGM)

        # Calculate the PIDF controller's output.
        pidCalculate(PIDF) # <--- This is where the magick happens. =^/,..,^=

        # Get the PIDF controller's output.
        # This is the throttle and brake values that will be applied to the locomotive.
        local PIDFOutput = pidGetOutput(PIDF)

        #[ Bypass all of this for now. ]#
        #[
            # Set the throttle and brake values based on the PIDF controller's output and the current reverser position.
            if (Reverser == 1)
            {
                Throttle = PIDFOutput
                Brake = 0
            }

            elseif (Reverser == -1)
            {
                Throttle = 0
                Brake = PIDFOutput
            }

            else
            {
                Throttle = 0
                Brake = 0
            }

            # Apply the throttle, brake, and reverser values to the locomotive's traction motors.
            semControlTrucks(Trucks, Throttle, Brake, Reverser)
        ]#

        # Apply the PIDF Controller's output directly to the locomotive's traction motors.
        if (!semDirectControlTrucks(Trucks, PIDFOutput, Reverser))
        {
            #[ 
                Notes from ZZ Cat:
                When 'semDirectControlTrucks()' returns false, the control loop is disabled.
                The E2 is also unlocked, so you can edit or remove it.
                This is to prevent the E2 from being locked forever.

                Through testing, I found a few things:
                - If the trucks are removed from the locomotive, 'semDirectControlTrucks()' will return false.
                  & the speedometer will show an "Invalid entity!" error.
                - If the entire locomotive is removed from the world, 'semDirectControlTrucks()' will return false.
                  & the error below will be printed.
            ]#

            # If the E2 is locked, unlock it.
            # This is to prevent the E2 from being locked forever.
            runOnTick(0)
            if (semE2IsLocked())
            {
                semUnlockE2()
            }

            # Print an error message.
            error("Failed to apply PIDF controller's output to locomotive's traction motors.")
        }
    }

    catch (Exception)
    {
        printColor(vec(255, 0, 0), "[RailDriver | PID | Error]", vec(255, 255, 255), ": " + Exception)
    }
}

if (keyClk())
{
    try
    {
        playerControlsUpdate(PlayerControls)

        #[
            Notes from ZZ Cat:
            This has been commented out, because it keeps spamming the chat with the same message.
            Currently, I'm not sure how to fix this.
            If you know how to fix this, please let me know by opening either an issue or a pull request on GitHub.
        ]#
        #[
            if (!playerControlsValid(PlayerControls, SpeedMPH))
            {
                playerControlsClearAllFaults(PlayerControls)
                error(playerControlsGetFaultMessage(PlayerControls))
            }
        ]#
        playerControlsValid(PlayerControls, SpeedMPH)
    }

    catch (Exception)
    {
        printColor(vec(255, 0, 0), "[RailDriver | PlyCtrls | Error]", vec(255, 255, 255), ": " + Exception)
    }
}

if (clk("Debug"))
{
    stoptimer("Debug")
    timer("Debug", 100)

    Debugger["Speed (Source)", number] = Speed
    Debugger["Speed (mph)", number] = SpeedMPH
}
