#[
    This file is a part of the RailDriver project.
    Copyright Â© 2022, Cassandra "ZZ Cat" Robinson. All rights reserved.
]#

@name RailDriver/lib/sensors/speedometer

function table speedoCreateInstance(InputPos:entity, InputNeg:entity)
{
    local S:table()
    S:clear()
    S["Clock Name", string] = "Speedometer"
    S["Clock Sampling Rate", number] = 100
    S["Differential Speed Positive Input", entity] = InputPos
    S["Differential Speed Negative Input", entity] = InputNeg

    S["Error Threshold", number] = 1.5
    S["Error Hysteresis", number] = (5 / 100) * S["Error Threshold", number]
    S["Error Hyst. High", number] = S["Error Threshold", number] + S["Error Hysteresis", number]
    S["Error Hyst. Low", number] = S["Error Threshold", number] - S["Error Hysteresis", number]

    S["Speed Data is Valid Flag", number] = 0
    return S
}

function number speedoSetSampleRate(S:table, ClockName:string, SampleRateMillis)
{
    local TimersInUse = getTimers()

    for (I = 1, TimersInUse:count())
    {
        if (TimersInUse[I, string] == ClockName)
        {
            return 0
        }
    }

    if (SampleRateMillis < (tickInterval() * 1000))
    {
        return 0
    }

    S["Clock Name", string] = ClockName
    S["Clock Sampling Rate", number] = SampleRateMillis

    return 1
}

function void speedoStartTimer(S:table)
{
    timer(S["Clock Name", string], S["Clock Sampling Rate", number])
}

function string speedoGetClockId(S:table)
{
    return S["Clock Name", string]
}

function void speedoClearAndRestartTimer(S:table)
{
    stoptimer(S["Clock Name", string])
    timer(S["Clock Name", string], S["Clock Sampling Rate", number])
}

function number speedoGetSpeed(S:table)
{
    # Differential inputs to speedometer.
    local InPos = S["Differential Speed Positive Input", entity]:velL():y()
    local InNeg = S["Differential Speed Negative Input", entity]:velL():y()
    local Delta = InPos + InNeg

    # An error is derived from the differential inputs.
    local Error = abs(Delta)
    local Output = 0

    Output = (InPos - InNeg) / 2

    # The error needs to be relatively small in order for the speedometer's data to be valid.
    if (Error <= 1.0)
    {
        S["Speed Data is Valid Flag", number] = 1
    }

    else
    {
        S["Speed Data is Valid Flag", number] = 0
    }

    # [TO-DO]: Linear interpolation between values.

    return Output
}